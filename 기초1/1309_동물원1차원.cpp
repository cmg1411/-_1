/*
    dp[i]=i번째에 동물을 넣는 방법의 수 (i번에는 동물이 무조건 있다.)
    ->> dp[i-1]에는 동물을 넣는 경우는 한가지 방법 밖에없다. 
        dp[i-2]부터는 동물을 넣을 수 도 있고 안넣을 수 도있다.

    dp[i] = dp[i-1] + (dp[i-2] + dp[i-2] + dp[i-3].....dp[1])*2
    dp[i] = i번째에는 동물을 무조건 넣는 방법의 수,
            i-1번째에는 동물을 i번째와 반대로 넣거나 넣지 않는 방법의 수가 된다.
            i-2번째까지는 넣거나 안넣거나 다 가능하게 된다.(i-1번째에서 넣지 않을 수 도 있으니까.)
    
    그런데 dp[i-2]부터 dp[1]까지 매번 더해주면 너무 크므로O(N^2)
    s[i-2]라는 배열을 새로 선언해서 O(N)으로 해결하자
    s[i]=i번째에 동물을 넣는 모든 방법의 수의 모든 합. (한 마리도 넣지 않는 경우=dp[0]=1)
    s[i]=(dp[i] + dp[i-1] + dp[i-2].....dp[1])

    답은 S[]에 들어있게 된다.(dp는 무조건 넣는 방법만 세었으므로.)
*/

#include<iostream>
using namespace std;

int dp[100001];
int s[100001];

int main(){
    cin.tie(nullptr);
    ios_base::sync_with_stdio(false);

    int n;
    cin >> n;
    
    dp[0]=1; //경우의 수 dp에서는 0번째는 1로 초기화
    s[0]=1;
    dp[1]=2;
    s[1]=dp[1]+dp[0];

    for(int i=2 ; i<=n ; i++){
        dp[i] = dp[i-1] + 2*s[i-2];
        s[i] = s[i-1] + dp[i];
        dp[i] %= 9901;
        s[i] %= 9901;
    }

    cout << s[n];

    return 0;
}